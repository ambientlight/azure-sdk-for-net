// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Maps.Mobility.Models;

namespace Azure.Maps.Mobility
{
    /// <summary> Model factory for read-only models. </summary>
    public static partial class MapsMobilityModelFactory
    {
        /// <summary> Initializes new instance of MetroAreaResponse class. </summary>
        /// <param name="results"> All resulting metro area details. </param>
        /// <returns> A new <see cref="Models.MetroAreaResponse"/> instance for mocking. </returns>
        public static MetroAreaResponse MetroAreaResponse(IReadOnlyList<MetroAreaResult> results = default)
        {
            results ??= new List<MetroAreaResult>();
            return new MetroAreaResponse(results);
        }

        /// <summary> Initializes new instance of MetroAreaResult class. </summary>
        /// <param name="metroId"> The metro area&apos;s Id for use with other API calls. </param>
        /// <param name="metroName"> The main display name of the metro. </param>
        /// <param name="geometry"> A valid `GeoJSON Polygon` geometry type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.6) for details. </param>
        /// <param name="viewport"> The viewport that covers the result represented by the top-left and bottom-right coordinates of the  viewport. </param>
        /// <returns> A new <see cref="Models.MetroAreaResult"/> instance for mocking. </returns>
        public static MetroAreaResult MetroAreaResult(int? metroId = default, string metroName = default, GeoJsonPolygon geometry = default, ResultViewport viewport = default)
        {
            return new MetroAreaResult(metroId, metroName, geometry, viewport);
        }

        /// <summary> Initializes new instance of GeoJsonPolygonData class. </summary>
        /// <param name="coordinates"> Coordinates for the `GeoJson Polygon` geometry type. </param>
        /// <returns> A new <see cref="Models.GeoJsonPolygonData"/> instance for mocking. </returns>
        public static GeoJsonPolygonData GeoJsonPolygonData(IReadOnlyList<IList<IList<double>>> coordinates = default)
        {
            coordinates ??= new List<IList<IList<double>>>();
            return new GeoJsonPolygonData(coordinates);
        }

        /// <summary> Initializes new instance of GeoJsonPolygon class. </summary>
        /// <param name="type"> Specifies the `GeoJSON` type. Must be one of the nine valid GeoJSON object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon, GeometryCollection, Feature and FeatureCollection. </param>
        /// <param name="coordinates"> Coordinates for the `GeoJson Polygon` geometry type. </param>
        /// <returns> A new <see cref="Models.GeoJsonPolygon"/> instance for mocking. </returns>
        public static GeoJsonPolygon GeoJsonPolygon(GeoJsonObjectType type = default, IReadOnlyList<IList<IList<double>>> coordinates = default)
        {
            coordinates ??= new List<IList<IList<double>>>();
            return new GeoJsonPolygon(type, coordinates);
        }

        /// <summary> Initializes new instance of ResultViewport class. </summary>
        /// <param name="topLeftPoint"> A location represented as a latitude and longitude. </param>
        /// <param name="btmRightPoint"> A location represented as a latitude and longitude. </param>
        /// <returns> A new <see cref="Models.ResultViewport"/> instance for mocking. </returns>
        public static ResultViewport ResultViewport(CoordinatesPair topLeftPoint = default, CoordinatesPair btmRightPoint = default)
        {
            return new ResultViewport(topLeftPoint, btmRightPoint);
        }

        /// <summary> Initializes new instance of CoordinatesPair class. </summary>
        /// <param name="latitude"> Latitude property. </param>
        /// <param name="longitude"> Longitude property. </param>
        /// <returns> A new <see cref="Models.CoordinatesPair"/> instance for mocking. </returns>
        public static CoordinatesPair CoordinatesPair(double? latitude = default, double? longitude = default)
        {
            return new CoordinatesPair(latitude, longitude);
        }

        /// <summary> Initializes new instance of MetroAreaInfoResponse class. </summary>
        /// <param name="metroName"> The name of the metro area. </param>
        /// <param name="isFaresSupported"> Indicates if public transit fares information is available in the metro area. Fare information is available through [Get Transit Route API](https://aka.ms/AzureMapsMobilityTransitRoute) and [Get Transit Itinerary APIs](https://aka.ms/AzureMapsMobilityTransitItinerary). </param>
        /// <param name="transitTypes"> Supported transit types in the metro area. Returned if specified in the request. </param>
        /// <param name="agencies"> A list of all public transit agencies operating in the given metro area. </param>
        /// <param name="alerts"> A list of all public transit alerts within the given metro area. </param>
        /// <returns> A new <see cref="Models.MetroAreaInfoResponse"/> instance for mocking. </returns>
        public static MetroAreaInfoResponse MetroAreaInfoResponse(string metroName = default, string isFaresSupported = default, IReadOnlyList<TransitTypeResult> transitTypes = default, IReadOnlyList<AgencyDetails> agencies = default, IReadOnlyList<AlertInformation> alerts = default)
        {
            transitTypes ??= new List<TransitTypeResult>();
            agencies ??= new List<AgencyDetails>();
            alerts ??= new List<AlertInformation>();
            return new MetroAreaInfoResponse(metroName, isFaresSupported, transitTypes, agencies, alerts);
        }

        /// <summary> Initializes new instance of TransitTypeResult class. </summary>
        /// <param name="transitType"> Supported public transit type. Returned if specified in the request. </param>
        /// <param name="captionOverride"> For metro areas in which local name is different than the GTFS supported transit type, original name is returned. </param>
        /// <returns> A new <see cref="Models.TransitTypeResult"/> instance for mocking. </returns>
        public static TransitTypeResult TransitTypeResult(TransitType? transitType = default, string captionOverride = default)
        {
            return new TransitTypeResult(transitType, captionOverride);
        }

        /// <summary> Initializes new instance of AgencyDetails class. </summary>
        /// <param name="agencyId"> The Id of the relevant transit agency, for example, &apos;5872&apos;. </param>
        /// <param name="agencyKey"> The agency’s GTFS Id. </param>
        /// <param name="agencyName"> Name of the relevant transit agency, e.g. Metro Transit. </param>
        /// <param name="transitType"> Supported public transit type. One of Tram, Subway, Rail, Bus, Ferry, CableCar, Gondola, Funicular. </param>
        /// <returns> A new <see cref="Models.AgencyDetails"/> instance for mocking. </returns>
        public static AgencyDetails AgencyDetails(string agencyId = default, string agencyKey = default, string agencyName = default, TransitTypeResult transitType = default)
        {
            return new AgencyDetails(agencyId, agencyKey, agencyName, transitType);
        }

        /// <summary> Initializes new instance of AlertInformation class. </summary>
        /// <param name="alertSummary"> Text summarizing the alert. </param>
        /// <param name="publicationDate"> The date and time in ISO 8601 format, e.g. 2019-04-05T14:24:18-04:00. </param>
        /// <param name="category"> The category of the alert. One of None, Regular, Info, Modified, Critical. </param>
        /// <param name="alertLevel"> The level at which the respective alert extents to. One of Metro, Agency, Line, Stop. </param>
        /// <param name="details"> A list of alert details. </param>
        /// <returns> A new <see cref="Models.AlertInformation"/> instance for mocking. </returns>
        public static AlertInformation AlertInformation(string alertSummary = default, DateTimeOffset? publicationDate = default, string category = default, string alertLevel = default, AlertDetail details = default)
        {
            return new AlertInformation(alertSummary, publicationDate, category, alertLevel, details);
        }

        /// <summary> Initializes new instance of AlertDetail class. </summary>
        /// <param name="agencyId"> The Id of the relevant transit agency, for example, &apos;5872&apos;. </param>
        /// <param name="agencyName"> Name of the relevant transit agency, e.g. Metro Transit. </param>
        /// <param name="title"> The title of the alert. </param>
        /// <param name="description"> A short description of the alert. </param>
        /// <param name="activeFrom"> The start time of the alert in the local time in ISO format (2019-04-05T14:24:18-04:00). </param>
        /// <param name="activeTo"> The estimated end time of the alert in the local time in ISO format (2019-04-05T14:24:18-04:00). </param>
        /// <param name="effect"> Service Alert effect - one of SA_NO_SERVICE, SA_REDUCED_SERVICE, SA_SIGNIFICANT_DELAYS, SA_DETOUR, SA_ADDITIONAL_SERVICE, SA_MODIFIED_SERVICE, SA_OTHER_EFFECT, SA_STOP_MOVED, SA_GOOD_SERVICE, SA_SLEEPING, SA_OTHER_EFFECT. </param>
        /// <returns> A new <see cref="Models.AlertDetail"/> instance for mocking. </returns>
        public static AlertDetail AlertDetail(string agencyId = default, string agencyName = default, string title = default, AlertDescription description = default, DateTimeOffset? activeFrom = default, DateTimeOffset? activeTo = default, string effect = default)
        {
            return new AlertDetail(agencyId, agencyName, title, description, activeFrom, activeTo, effect);
        }

        /// <summary> Initializes new instance of AlertDescription class. </summary>
        /// <param name="data"> Description of the alert. </param>
        /// <param name="format"> Format of the alert description. </param>
        /// <param name="sourceUrl"> Source URL. </param>
        /// <returns> A new <see cref="Models.AlertDescription"/> instance for mocking. </returns>
        public static AlertDescription AlertDescription(string data = default, string format = default, string sourceUrl = default)
        {
            return new AlertDescription(data, format, sourceUrl);
        }

        /// <summary> Initializes new instance of NearbyTransitResponse class. </summary>
        /// <param name="results"> All resulting nearby transit details. </param>
        /// <returns> A new <see cref="Models.NearbyTransitResponse"/> instance for mocking. </returns>
        public static NearbyTransitResponse NearbyTransitResponse(IReadOnlyList<TransitObjectResult> results = default)
        {
            results ??= new List<TransitObjectResult>();
            return new NearbyTransitResponse(results);
        }

        /// <summary> Initializes new instance of TransitObjectResult class. </summary>
        /// <param name="id"> The unique identifier (stopID) for the returned public transit stop. When referring to public transit stops over time, it is recommended to use `stopId` since it will not change, as long as the physical stop exists. </param>
        /// <param name="type"> The type of object found as a result of the query. </param>
        /// <param name="objectDetails"> The object specific details. </param>
        /// <param name="position"> The transit object&apos;s position. </param>
        /// <param name="viewport"> The viewport that covers the result represented by the top-left and bottom-right coordinates of the  viewport. </param>
        /// <returns> A new <see cref="Models.TransitObjectResult"/> instance for mocking. </returns>
        public static TransitObjectResult TransitObjectResult(string id = default, string type = default, object objectDetails = default, CoordinatesPair position = default, ResultViewport viewport = default)
        {
            return new TransitObjectResult(id, type, objectDetails, position, viewport);
        }

        /// <summary> Initializes new instance of TransitLineInfoResponse class. </summary>
        /// <param name="lineGroup"> Groups together all lines that are logically part of the same group. Typically contains 2 lines having the same agency and line, one going from A to B, and the other from B to A. </param>
        /// <param name="lines"> The line group’s basic info and list of the lines. </param>
        /// <param name="stops"> List of stops the line group goes through. </param>
        /// <param name="patterns"> List of patterns this group is comprised of. A pattern consists of a stop sequence and shape per a line in GeoJSON format. </param>
        /// <param name="schedule"> Line schedule for the current 24h. May be null in case no schedule exists for the current time. </param>
        /// <returns> A new <see cref="Models.TransitLineInfoResponse"/> instance for mocking. </returns>
        public static TransitLineInfoResponse TransitLineInfoResponse(ItineraryLineGroup lineGroup = default, IReadOnlyList<ItineraryLine> lines = default, IReadOnlyList<LegStop> stops = default, IReadOnlyList<ItineraryPattern> patterns = default, LineArrival schedule = default)
        {
            lines ??= new List<ItineraryLine>();
            stops ??= new List<LegStop>();
            patterns ??= new List<ItineraryPattern>();
            return new TransitLineInfoResponse(lineGroup, lines, stops, patterns, schedule);
        }

        /// <summary> Initializes new instance of ItineraryLineGroup class. </summary>
        /// <param name="lineGroupId"> Line group Id. Typically contains 2 lines having the same agency and line, one going from A to B, and the other from B to A. </param>
        /// <param name="agencyId"> The Id of the transit agency, for example, &apos;5872&apos;. </param>
        /// <param name="agencyName"> The name of the transit agency, e.g. Metro Transit. </param>
        /// <param name="lineNumber"> The transit line number. </param>
        /// <param name="caption1"> A descriptive string. In case caption2 is null, should be used alone as a subtitle to the line number (i.e. Circular). In case caption2 has a value present, should be used in conjunction with it (i.e. Rome ↔ Napoli). </param>
        /// <param name="caption2"> A descriptive string. </param>
        /// <param name="color"> HEX color for the line. </param>
        /// <param name="transitType"> The public transit type of the line. </param>
        /// <returns> A new <see cref="Models.ItineraryLineGroup"/> instance for mocking. </returns>
        public static ItineraryLineGroup ItineraryLineGroup(string lineGroupId = default, string agencyId = default, string agencyName = default, string lineNumber = default, string caption1 = default, string caption2 = default, string color = default, TransitType? transitType = default)
        {
            return new ItineraryLineGroup(lineGroupId, agencyId, agencyName, lineNumber, caption1, caption2, color, transitType);
        }

        /// <summary> Initializes new instance of ItineraryLine class. </summary>
        /// <param name="lineId"> Line Id. </param>
        /// <param name="lineGroupId"> Line group Id. Typically contains 2 lines having the same agency and line, one going from A to B, and the other from B to A. </param>
        /// <param name="direction"> Line direction. Possible values &apos;forward&apos; or &apos;backward&apos;. </param>
        /// <param name="agencyId"> The Id of the transit agency, for example, &apos;5872&apos;. </param>
        /// <param name="agencyName"> The name of the transit agency, for example, &apos;NJ Transit&apos;. </param>
        /// <param name="lineNumber"> The transit line number. </param>
        /// <param name="origin"> The line’s origin, will be present according to metro settings. </param>
        /// <param name="lineDestination"> The line’s user displayable destination. </param>
        /// <param name="mostFrequentPatternId"> Most common pattern for the line. </param>
        /// <param name="transitType"> The public transit type of the line. </param>
        /// <returns> A new <see cref="Models.ItineraryLine"/> instance for mocking. </returns>
        public static ItineraryLine ItineraryLine(string lineId = default, string lineGroupId = default, string direction = default, string agencyId = default, string agencyName = default, string lineNumber = default, string origin = default, string lineDestination = default, string mostFrequentPatternId = default, TransitType? transitType = default)
        {
            return new ItineraryLine(lineId, lineGroupId, direction, agencyId, agencyName, lineNumber, origin, lineDestination, mostFrequentPatternId, transitType);
        }

        /// <summary> Initializes new instance of LegStop class. </summary>
        /// <param name="stopId"> The unique Azure Maps identifier for the respective public transit stop. When referring to public transit stops over time, it is recommended to use `stopId` since it will not change, as long as the physical stop exists. </param>
        /// <param name="stopKey"> The GTFS stop Id. GTFS stop Ids are provided by the transit authority and subject to change. </param>
        /// <param name="stopName"> The name of the stop. </param>
        /// <param name="stopCode"> The stop code displayed at the physical stop. Returned if available. </param>
        /// <param name="position"> The Stop&apos;s location, latitude and longitude. </param>
        /// <param name="mainTransitType"> The transit type of most lines stopping at this stop. One of Tram, Subway, Rail, Bus, Ferry, CableCar, Gondola, Funicular. </param>
        /// <param name="mainAgencyId"> The Id of the transit agency of most lines stopping at this stop. For example &apos;5872&apos;. </param>
        /// <param name="mainAgencyName"> The name of the agency of most lines stopping at this stop, for example, &apos;Metro Transit&apos;. </param>
        /// <returns> A new <see cref="Models.LegStop"/> instance for mocking. </returns>
        public static LegStop LegStop(string stopId = default, string stopKey = default, string stopName = default, string stopCode = default, CoordinatesPair position = default, string mainTransitType = default, string mainAgencyId = default, string mainAgencyName = default)
        {
            return new LegStop(stopId, stopKey, stopName, stopCode, position, mainTransitType, mainAgencyId, mainAgencyName);
        }

        /// <summary> Initializes new instance of ItineraryPattern class. </summary>
        /// <param name="patternId"> Pattern Id, for example, &apos;3267995&apos;. </param>
        /// <param name="lineId"> Line Id. </param>
        /// <param name="stopIds"> Stops the line goes through. </param>
        /// <param name="geometry"> Stop sequence and shape per a line in GeoJSON format. </param>
        /// <returns> A new <see cref="Models.ItineraryPattern"/> instance for mocking. </returns>
        public static ItineraryPattern ItineraryPattern(string patternId = default, string lineId = default, IReadOnlyList<string> stopIds = default, GeoJsonLineString geometry = default)
        {
            stopIds ??= new List<string>();
            return new ItineraryPattern(patternId, lineId, stopIds, geometry);
        }

        /// <summary> Initializes new instance of GeoJsonLineStringData class. </summary>
        /// <param name="coordinates"> Coordinates for the `GeoJson LineString` geometry. </param>
        /// <returns> A new <see cref="Models.GeoJsonLineStringData"/> instance for mocking. </returns>
        public static GeoJsonLineStringData GeoJsonLineStringData(IReadOnlyList<IList<double>> coordinates = default)
        {
            coordinates ??= new List<IList<double>>();
            return new GeoJsonLineStringData(coordinates);
        }

        /// <summary> Initializes new instance of GeoJsonLineString class. </summary>
        /// <param name="type"> Specifies the `GeoJSON` type. Must be one of the nine valid GeoJSON object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon, GeometryCollection, Feature and FeatureCollection. </param>
        /// <param name="coordinates"> Coordinates for the `GeoJson LineString` geometry. </param>
        /// <returns> A new <see cref="Models.GeoJsonLineString"/> instance for mocking. </returns>
        public static GeoJsonLineString GeoJsonLineString(GeoJsonObjectType type = default, IReadOnlyList<IList<double>> coordinates = default)
        {
            coordinates ??= new List<IList<double>>();
            return new GeoJsonLineString(type, coordinates);
        }

        /// <summary> Initializes new instance of LineArrival class. </summary>
        /// <param name="lineId"> Line Id. </param>
        /// <param name="stopId"> The unique Azure Maps identifier for the respective public transit stop. When referring to public transit stops over time, it is recommended to use `stopId` since it will not change, as long as the physical stop exists. </param>
        /// <param name="scheduleTime"> The date and time of departure from the stop in ISO 8601 format, e.g. 1996-12-19T19:39:57-08:00. </param>
        /// <param name="scheduleType"> Whether the result is based on real-time or static data. </param>
        /// <returns> A new <see cref="Models.LineArrival"/> instance for mocking. </returns>
        public static LineArrival LineArrival(string lineId = default, string stopId = default, DateTimeOffset? scheduleTime = default, ScheduleType? scheduleType = default)
        {
            return new LineArrival(lineId, stopId, scheduleTime, scheduleType);
        }

        /// <summary> Initializes new instance of TransitStopInfoResponse class. </summary>
        /// <param name="stop"> The stop&apos;s basic info. </param>
        /// <param name="lines"> A list of stop lines. </param>
        /// <param name="lineGroups"> A list of line groups. </param>
        /// <param name="alerts"> A list of stop alerts. </param>
        /// <returns> A new <see cref="Models.TransitStopInfoResponse"/> instance for mocking. </returns>
        public static TransitStopInfoResponse TransitStopInfoResponse(LegStop stop = default, IReadOnlyList<ItineraryLine> lines = default, IReadOnlyList<ItineraryLineGroup> lineGroups = default, IReadOnlyList<AlertInformation> alerts = default)
        {
            lines ??= new List<ItineraryLine>();
            lineGroups ??= new List<ItineraryLineGroup>();
            alerts ??= new List<AlertInformation>();
            return new TransitStopInfoResponse(stop, lines, lineGroups, alerts);
        }

        /// <summary> Initializes new instance of TransitRouteResponse class. </summary>
        /// <param name="results"> All resulting transit stops details. </param>
        /// <returns> A new <see cref="Models.TransitRouteResponse"/> instance for mocking. </returns>
        public static TransitRouteResponse TransitRouteResponse(IReadOnlyList<ItineraryResult> results = default)
        {
            results ??= new List<ItineraryResult>();
            return new TransitRouteResponse(results);
        }

        /// <summary> Initializes new instance of ItineraryResult class. </summary>
        /// <param name="itineraryId"> A unique identifier of the returned itinerary. </param>
        /// <param name="departureTime"> The date and time of departure from the origin point in ISO 8601 format, e.g. 1996-12-19T16:39:57-08:00. </param>
        /// <param name="arrivalTime"> The date and time of arrival at the destination point in ISO 8601 format, e.g. 1996-12-19T19:39:57-08:00. </param>
        /// <param name="travelTimeInSeconds"> Estimated travel time in seconds. </param>
        /// <param name="numberOfLegs"> Number of legs. </param>
        /// <param name="legs"> An array summarizing the legs of this itinerary. </param>
        /// <param name="itineraryFare"> Itinerary level transit fare information. Returned only if fare information is available for the entire itinerary. [Get Metro Area Info API](https://aka.ms/AzureMapsMobilityMetroAreaInfo) can be requested to confirm if fare information is available in the metro area. </param>
        /// <returns> A new <see cref="Models.ItineraryResult"/> instance for mocking. </returns>
        public static ItineraryResult ItineraryResult(string itineraryId = default, DateTimeOffset? departureTime = default, DateTimeOffset? arrivalTime = default, int? travelTimeInSeconds = default, int? numberOfLegs = default, IReadOnlyList<RouteItineraryLeg> legs = default, ItineraryFare itineraryFare = default)
        {
            legs ??= new List<RouteItineraryLeg>();
            return new ItineraryResult(itineraryId, departureTime, arrivalTime, travelTimeInSeconds, numberOfLegs, legs, itineraryFare);
        }

        /// <summary> Initializes new instance of RouteItineraryLeg class. </summary>
        /// <param name="legType"> The travel mode of the leg. </param>
        /// <param name="legFare"> Leg level public transit fare information. Returned only if fare information is available for the entire itinerary. </param>
        /// <param name="legStartTime"> Start time for the leg in ISO 8601 format, e.g. 1996-12-19T19:39:57-08:00. </param>
        /// <param name="legEndTime"> End time for the leg in ISO 8601 format, e.g. 1996-12-19T19:39:57-08:00. </param>
        /// <param name="caption"> For Public Transit legs the caption of the line serving the leg, for example, line number. </param>
        /// <param name="lengthInMeters"> The total distance of the leg in meters. </param>
        /// <returns> A new <see cref="Models.RouteItineraryLeg"/> instance for mocking. </returns>
        public static RouteItineraryLeg RouteItineraryLeg(LegType? legType = default, LegFare legFare = default, string legStartTime = default, string legEndTime = default, string caption = default, int? lengthInMeters = default)
        {
            return new RouteItineraryLeg(legType, legFare, legStartTime, legEndTime, caption, lengthInMeters);
        }

        /// <summary> Initializes new instance of LegFare class. </summary>
        /// <param name="fares"> Details of the fare. </param>
        /// <returns> A new <see cref="Models.LegFare"/> instance for mocking. </returns>
        public static LegFare LegFare(IReadOnlyList<FareDetail> fares = default)
        {
            fares ??= new List<FareDetail>();
            return new LegFare(fares);
        }

        /// <summary> Initializes new instance of FareDetail class. </summary>
        /// <param name="price"> The price of the ticket when purchased for the individual leg, not for the entire route at once. </param>
        /// <param name="usage">
        /// Supported values are:
        /// 
        ///   * pay – user is expected to pay for this ticket in order to consume the current leg
        ///   * transfer – user can use a ticket purchased in a previous leg in order to consume the current leg. In general, when transfer is specified, the number of transfers is counted, and has a limit.
        ///   * continue – user can use a ticket purchased in a previous leg in order to consume the current leg. In general, when continue is specified, the number of transfers isn’t incremented for this leg.
        ///   * upgrade – user is expected to upgrade a ticket purchased in a previous leg in order to consume the current leg.
        /// </param>
        /// <returns> A new <see cref="Models.FareDetail"/> instance for mocking. </returns>
        public static FareDetail FareDetail(FarePrice price = default, string usage = default)
        {
            return new FareDetail(price, usage);
        }

        /// <summary> Initializes new instance of FarePrice class. </summary>
        /// <param name="amount"> Price of the ticket in cents. For example, $5.00 is returned as ‘500’. </param>
        /// <param name="currencyCode"> Currency code, for example for US dollars “USD”. </param>
        /// <returns> A new <see cref="Models.FarePrice"/> instance for mocking. </returns>
        public static FarePrice FarePrice(int? amount = default, string currencyCode = default)
        {
            return new FarePrice(amount, currencyCode);
        }

        /// <summary> Initializes new instance of ItineraryFare class. </summary>
        /// <param name="price"> The total price for all tickets a user is expected to purchase in order to complete this itinerary. </param>
        /// <param name="tickets"> An array describing the individual prices of each of the tickets that the user is expected to purchase throughout this itinerary. The list isn’t ordered. </param>
        /// <returns> A new <see cref="Models.ItineraryFare"/> instance for mocking. </returns>
        public static ItineraryFare ItineraryFare(FarePrice price = default, IReadOnlyList<FareTicket> tickets = default)
        {
            tickets ??= new List<FareTicket>();
            return new ItineraryFare(price, tickets);
        }

        /// <summary> Initializes new instance of FareTicket class. </summary>
        /// <param name="amount"> Price of the ticket in cents. For example, $5.00 is returned as ‘500’. </param>
        /// <param name="currencyCode"> Currency code, for example for US dollars “USD”. </param>
        /// <returns> A new <see cref="Models.FareTicket"/> instance for mocking. </returns>
        public static FareTicket FareTicket(int? amount = default, string currencyCode = default)
        {
            return new FareTicket(amount, currencyCode);
        }

        /// <summary> Initializes new instance of TransitItineraryResponse class. </summary>
        /// <param name="departureTime"> The date and time of departure from the origin point in ISO 8601 format, e.g. 1996-12-19T16:39:57-08:00. </param>
        /// <param name="arrivalTime"> The date and time of arrival at the destination point in ISO 8601 format, e.g. 1996-12-19T19:39:57-08:00. </param>
        /// <param name="legs"> An array summarizing the legs of this itinerary. </param>
        /// <param name="itineraryFare"> Itinerary level transit fare information. Returned only if fare information is available for the entire itinerary. [Get Metro Area Info API](https://aka.ms/AzureMapsMobilityMetroAreaInfo) can be requested to confirm if fare information is available in the metro area. </param>
        /// <returns> A new <see cref="Models.TransitItineraryResponse"/> instance for mocking. </returns>
        public static TransitItineraryResponse TransitItineraryResponse(string departureTime = default, string arrivalTime = default, IReadOnlyList<ItineraryLeg> legs = default, ItineraryFare itineraryFare = default)
        {
            legs ??= new List<ItineraryLeg>();
            return new TransitItineraryResponse(departureTime, arrivalTime, legs, itineraryFare);
        }

        /// <summary> Initializes new instance of ItineraryLeg class. </summary>
        /// <param name="legType"> The travel mode of the leg. </param>
        /// <param name="legStartTime"> Start time for the leg. </param>
        /// <param name="legEndTime"> End time for the leg. </param>
        /// <param name="steps"> In case of walk or bike leg, the directions. </param>
        /// <param name="origin"> The walk/bike leg’s origin. </param>
        /// <param name="destination"> The walk/bike leg’s destination. </param>
        /// <param name="geometry"> A valid `GeoJSON LineString` geometry type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.4) for details. </param>
        /// <param name="lineGroup"> In case of a public transit leg, the line group serving this leg. </param>
        /// <param name="line"> In case of a public transit leg, the line serving this leg. </param>
        /// <param name="stops"> List of stops comprising the line’s route within the leg (e.g. the stops the leg passes through). </param>
        /// <param name="departures"> Relevant for Public Transit and Wait legs only. </param>
        /// <param name="legFare"> Leg level public transit fare information. Returned only if fare information is available for the entire itinerary. </param>
        /// <param name="waitOnVehicle"> Indicates whether it’s necessary to wait for the next leg on the same vehicle (i.e. the bus will only change its line number). </param>
        /// <returns> A new <see cref="Models.ItineraryLeg"/> instance for mocking. </returns>
        public static ItineraryLeg ItineraryLeg(LegType? legType = default, string legStartTime = default, string legEndTime = default, IReadOnlyList<ItineraryStep> steps = default, LegPoint origin = default, LegPoint destination = default, GeoJsonLineString geometry = default, ItineraryLineGroup lineGroup = default, ItineraryLine line = default, IReadOnlyList<LegStop> stops = default, IReadOnlyList<LineArrival> departures = default, LegFare legFare = default, string waitOnVehicle = default)
        {
            steps ??= new List<ItineraryStep>();
            stops ??= new List<LegStop>();
            departures ??= new List<LineArrival>();
            return new ItineraryLeg(legType, legStartTime, legEndTime, steps, origin, destination, geometry, lineGroup, line, stops, departures, legFare, waitOnVehicle);
        }

        /// <summary> Initializes new instance of ItineraryStep class. </summary>
        /// <param name="direction"> The walking direction associated with this step. </param>
        /// <param name="streetName"> The name of the street in which this step takes place. </param>
        /// <returns> A new <see cref="Models.ItineraryStep"/> instance for mocking. </returns>
        public static ItineraryStep ItineraryStep(WalkingDirection direction = default, string streetName = default)
        {
            return new ItineraryStep(direction, streetName);
        }

        /// <summary> Initializes new instance of WalkingDirection class. </summary>
        /// <param name="relativeDirection"> The relative walking direction associated with applicable step. </param>
        /// <param name="absoluteDirection"> The absolute walking direction associated with this step. </param>
        /// <returns> A new <see cref="Models.WalkingDirection"/> instance for mocking. </returns>
        public static WalkingDirection WalkingDirection(RelativeDirection? relativeDirection = default, AbsoluteDirection? absoluteDirection = default)
        {
            return new WalkingDirection(relativeDirection, absoluteDirection);
        }

        /// <summary> Initializes new instance of LegPoint class. </summary>
        /// <param name="position"> A location represented as a latitude and longitude. </param>
        /// <returns> A new <see cref="Models.LegPoint"/> instance for mocking. </returns>
        public static LegPoint LegPoint(CoordinatesPair position = default)
        {
            return new LegPoint(position);
        }

        /// <summary> Initializes new instance of RealTimeArrivalsResponse class. </summary>
        /// <param name="results"> Results array. Contains results related details. </param>
        /// <returns> A new <see cref="Models.RealTimeArrivalsResponse"/> instance for mocking. </returns>
        public static RealTimeArrivalsResponse RealTimeArrivalsResponse(IReadOnlyList<RealTimeArrivalResult> results = default)
        {
            results ??= new List<RealTimeArrivalResult>();
            return new RealTimeArrivalsResponse(results);
        }

        /// <summary> Initializes new instance of RealTimeArrivalResult class. </summary>
        /// <param name="arrivalMinutes"> The estimated time of arrival in minutes. </param>
        /// <param name="scheduleType"> Whether the result is based on real-time or static data. </param>
        /// <param name="patternId"> The pattern Id. </param>
        /// <param name="line"> The public transit type of the line. </param>
        /// <param name="stop"> Object for the given stop. </param>
        /// <returns> A new <see cref="Models.RealTimeArrivalResult"/> instance for mocking. </returns>
        public static RealTimeArrivalResult RealTimeArrivalResult(int? arrivalMinutes = default, ScheduleType? scheduleType = default, string patternId = default, ItineraryLine line = default, LegStop stop = default)
        {
            return new RealTimeArrivalResult(arrivalMinutes, scheduleType, patternId, line, stop);
        }

        /// <summary> Initializes new instance of GeoJsonPointData class. </summary>
        /// <param name="coordinates"> A `Position` is an array of numbers with two or more elements. The first two elements are _longitude_ and _latitude_, precisely in that order. _Altitude/Elevation_ is an optional third element. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.1) for details. </param>
        /// <returns> A new <see cref="Models.GeoJsonPointData"/> instance for mocking. </returns>
        public static GeoJsonPointData GeoJsonPointData(IReadOnlyList<double> coordinates = default)
        {
            coordinates ??= new List<double>();
            return new GeoJsonPointData(coordinates);
        }

        /// <summary> Initializes new instance of GeoJsonPoint class. </summary>
        /// <param name="type"> Specifies the `GeoJSON` type. Must be one of the nine valid GeoJSON object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon, GeometryCollection, Feature and FeatureCollection. </param>
        /// <param name="coordinates"> A `Position` is an array of numbers with two or more elements. The first two elements are _longitude_ and _latitude_, precisely in that order. _Altitude/Elevation_ is an optional third element. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.1) for details. </param>
        /// <returns> A new <see cref="Models.GeoJsonPoint"/> instance for mocking. </returns>
        public static GeoJsonPoint GeoJsonPoint(GeoJsonObjectType type = default, IReadOnlyList<double> coordinates = default)
        {
            coordinates ??= new List<double>();
            return new GeoJsonPoint(type, coordinates);
        }

        /// <summary> Initializes new instance of GeoJsonMultiPointData class. </summary>
        /// <param name="coordinates"> Coordinates for the `GeoJson MultiPoint` geometry. </param>
        /// <returns> A new <see cref="Models.GeoJsonMultiPointData"/> instance for mocking. </returns>
        public static GeoJsonMultiPointData GeoJsonMultiPointData(IReadOnlyList<IList<double>> coordinates = default)
        {
            coordinates ??= new List<IList<double>>();
            return new GeoJsonMultiPointData(coordinates);
        }

        /// <summary> Initializes new instance of GeoJsonMultiPoint class. </summary>
        /// <param name="type"> Specifies the `GeoJSON` type. Must be one of the nine valid GeoJSON object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon, GeometryCollection, Feature and FeatureCollection. </param>
        /// <param name="coordinates"> Coordinates for the `GeoJson MultiPoint` geometry. </param>
        /// <returns> A new <see cref="Models.GeoJsonMultiPoint"/> instance for mocking. </returns>
        public static GeoJsonMultiPoint GeoJsonMultiPoint(GeoJsonObjectType type = default, IReadOnlyList<IList<double>> coordinates = default)
        {
            coordinates ??= new List<IList<double>>();
            return new GeoJsonMultiPoint(type, coordinates);
        }

        /// <summary> Initializes new instance of GeoJsonMultiLineStringData class. </summary>
        /// <param name="coordinates"> Coordinates for the `GeoJson MultiLineString` geometry. </param>
        /// <returns> A new <see cref="Models.GeoJsonMultiLineStringData"/> instance for mocking. </returns>
        public static GeoJsonMultiLineStringData GeoJsonMultiLineStringData(IReadOnlyList<IList<IList<double>>> coordinates = default)
        {
            coordinates ??= new List<IList<IList<double>>>();
            return new GeoJsonMultiLineStringData(coordinates);
        }

        /// <summary> Initializes new instance of GeoJsonMultiLineString class. </summary>
        /// <param name="type"> Specifies the `GeoJSON` type. Must be one of the nine valid GeoJSON object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon, GeometryCollection, Feature and FeatureCollection. </param>
        /// <param name="coordinates"> Coordinates for the `GeoJson MultiLineString` geometry. </param>
        /// <returns> A new <see cref="Models.GeoJsonMultiLineString"/> instance for mocking. </returns>
        public static GeoJsonMultiLineString GeoJsonMultiLineString(GeoJsonObjectType type = default, IReadOnlyList<IList<IList<double>>> coordinates = default)
        {
            coordinates ??= new List<IList<IList<double>>>();
            return new GeoJsonMultiLineString(type, coordinates);
        }

        /// <summary> Initializes new instance of GeoJsonMultiPolygonData class. </summary>
        /// <param name="coordinates"> Contains a list of valid `GeoJSON Polygon` objects. **Note** that coordinates in GeoJSON are in x, y order (longitude, latitude). </param>
        /// <returns> A new <see cref="Models.GeoJsonMultiPolygonData"/> instance for mocking. </returns>
        public static GeoJsonMultiPolygonData GeoJsonMultiPolygonData(IReadOnlyList<IList<IList<IList<double>>>> coordinates = default)
        {
            coordinates ??= new List<IList<IList<IList<double>>>>();
            return new GeoJsonMultiPolygonData(coordinates);
        }

        /// <summary> Initializes new instance of GeoJsonMultiPolygon class. </summary>
        /// <param name="type"> Specifies the `GeoJSON` type. Must be one of the nine valid GeoJSON object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon, GeometryCollection, Feature and FeatureCollection. </param>
        /// <param name="coordinates"> Contains a list of valid `GeoJSON Polygon` objects. **Note** that coordinates in GeoJSON are in x, y order (longitude, latitude). </param>
        /// <returns> A new <see cref="Models.GeoJsonMultiPolygon"/> instance for mocking. </returns>
        public static GeoJsonMultiPolygon GeoJsonMultiPolygon(GeoJsonObjectType type = default, IReadOnlyList<IList<IList<IList<double>>>> coordinates = default)
        {
            coordinates ??= new List<IList<IList<IList<double>>>>();
            return new GeoJsonMultiPolygon(type, coordinates);
        }

        /// <summary> Initializes new instance of GeoJsonGeometryCollectionData class. </summary>
        /// <param name="geometries"> Contains a list of valid `GeoJSON` geometry objects. **Note** that coordinates in GeoJSON are in x, y order (longitude, latitude). </param>
        /// <returns> A new <see cref="Models.GeoJsonGeometryCollectionData"/> instance for mocking. </returns>
        public static GeoJsonGeometryCollectionData GeoJsonGeometryCollectionData(IReadOnlyList<GeoJsonGeometry> geometries = default)
        {
            geometries ??= new List<GeoJsonGeometry>();
            return new GeoJsonGeometryCollectionData(geometries);
        }

        /// <summary> Initializes new instance of GeoJsonGeometryCollection class. </summary>
        /// <param name="type"> Specifies the `GeoJSON` type. Must be one of the nine valid GeoJSON object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon, GeometryCollection, Feature and FeatureCollection. </param>
        /// <param name="geometries"> Contains a list of valid `GeoJSON` geometry objects. **Note** that coordinates in GeoJSON are in x, y order (longitude, latitude). </param>
        /// <returns> A new <see cref="Models.GeoJsonGeometryCollection"/> instance for mocking. </returns>
        public static GeoJsonGeometryCollection GeoJsonGeometryCollection(GeoJsonObjectType type = default, IReadOnlyList<GeoJsonGeometry> geometries = default)
        {
            geometries ??= new List<GeoJsonGeometry>();
            return new GeoJsonGeometryCollection(type, geometries);
        }

        /// <summary> Initializes new instance of GeoJsonFeatureData class. </summary>
        /// <param name="geometry"> A valid `GeoJSON` geometry object. The type must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and GeometryCollection. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1) for details. </param>
        /// <param name="properties"> Properties can contain any additional metadata about the `Feature`. Value can be any JSON object or a JSON null value. </param>
        /// <param name="id"> Identifier for the feature. </param>
        /// <param name="featureType"> The type of the feature. The value depends on the data model the current feature is part of. Some data models may have an empty value. </param>
        /// <returns> A new <see cref="Models.GeoJsonFeatureData"/> instance for mocking. </returns>
        public static GeoJsonFeatureData GeoJsonFeatureData(GeoJsonGeometry geometry = default, object properties = default, string id = default, string featureType = default)
        {
            return new GeoJsonFeatureData(geometry, properties, id, featureType);
        }

        /// <summary> Initializes new instance of GeoJsonFeature class. </summary>
        /// <param name="type"> Specifies the `GeoJSON` type. Must be one of the nine valid GeoJSON object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon, GeometryCollection, Feature and FeatureCollection. </param>
        /// <param name="geometry"> A valid `GeoJSON` geometry object. The type must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and GeometryCollection. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1) for details. </param>
        /// <param name="properties"> Properties can contain any additional metadata about the `Feature`. Value can be any JSON object or a JSON null value. </param>
        /// <param name="id"> Identifier for the feature. </param>
        /// <param name="featureType"> The type of the feature. The value depends on the data model the current feature is part of. Some data models may have an empty value. </param>
        /// <returns> A new <see cref="Models.GeoJsonFeature"/> instance for mocking. </returns>
        public static GeoJsonFeature GeoJsonFeature(GeoJsonObjectType type = default, GeoJsonGeometry geometry = default, object properties = default, string id = default, string featureType = default)
        {
            return new GeoJsonFeature(type, geometry, properties, id, featureType);
        }

        /// <summary> Initializes new instance of GeoJsonFeatureCollectionData class. </summary>
        /// <param name="features"> Contains a list of valid `GeoJSON Feature` objects. </param>
        /// <returns> A new <see cref="Models.GeoJsonFeatureCollectionData"/> instance for mocking. </returns>
        public static GeoJsonFeatureCollectionData GeoJsonFeatureCollectionData(IReadOnlyList<GeoJsonFeature> features = default)
        {
            features ??= new List<GeoJsonFeature>();
            return new GeoJsonFeatureCollectionData(features);
        }

        /// <summary> Initializes new instance of GeoJsonFeatureCollection class. </summary>
        /// <param name="type"> Specifies the `GeoJSON` type. Must be one of the nine valid GeoJSON object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon, GeometryCollection, Feature and FeatureCollection. </param>
        /// <param name="features"> Contains a list of valid `GeoJSON Feature` objects. </param>
        /// <returns> A new <see cref="Models.GeoJsonFeatureCollection"/> instance for mocking. </returns>
        public static GeoJsonFeatureCollection GeoJsonFeatureCollection(GeoJsonObjectType type = default, IReadOnlyList<GeoJsonFeature> features = default)
        {
            features ??= new List<GeoJsonFeature>();
            return new GeoJsonFeatureCollection(type, features);
        }
    }
}
